// Code Generated by Sidekick is for learning and experimentation purposes only.

import 'package:flutter/cupertino.dart';
import 'package:flutter/material.dart';

import 'csv_box.dart';

class CsvTable extends StatefulWidget {
  final List<String> types;
  final Map<String, List<Map<String, dynamic>>> columnsByType;
  final Map<String, List<List<GlobalKey>>> columnKeysByType;
  final Map<String, Color> cellColors;
  final List<Connection> connections;
  final GlobalKey stackKey;
  final double horizontalSpacing;
  final double csvBoxWidth;
  final void Function(Connection, String, String) onConnection;
  final ScrollController scrollController;
  final double authoritativeHeight;
  final double idmHeight;
  final double targetHeight;
  final Map<String, List<GlobalKey>> csvBoxKeysByType;

  const CsvTable({
    required this.types,
    required this.columnsByType,
    required this.columnKeysByType,
    required this.cellColors,
    required this.connections,
    required this.stackKey,
    required this.horizontalSpacing,
    required this.csvBoxWidth,
    required this.onConnection,
    required this.scrollController,
    required this.authoritativeHeight,
    required this.idmHeight,
    required this.targetHeight,
    required this.csvBoxKeysByType,
    super.key,
  });

  @override
  State<CsvTable> createState() => _CsvTableState();
}

class _CsvTableState extends State<CsvTable> {
  late final ScrollController idmScrollController;
  final double boxHeight = 70.0; // Ensure this matches your CsvBox height

  @override
  void initState() {
    super.initState();
    idmScrollController = ScrollController();
  }

  @override
  void dispose() {
    idmScrollController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final types = widget.types; // ['Authoritative', 'IDM', 'Target']
    final columnsByType = widget.columnsByType;
    final columnKeysByType = widget.columnKeysByType;
    final csvBoxKeysByType = widget.csvBoxKeysByType;

    final nAuthoritative = columnsByType['Authoritative']?.length ?? 0;
    final nTarget = columnsByType['Target']?.length ?? 0;
    final nIDM = columnsByType['IDM']?.length ?? 0;
    final int maxRows = [nAuthoritative, nIDM, nTarget].reduce((a, b) => a > b ? a : b);

    // Use measured heights for more accurate spacing
    final double authoritativeHeight = widget.authoritativeHeight;
    final double targetHeight = widget.targetHeight;

    // Authoritative gap: only if Target > Authoritative
    final double authoritativeGap = (nTarget > nAuthoritative)
        ? ((nTarget - nAuthoritative) * targetHeight) / 2
        : 0.0;

    // IDM gap: always based on Authoritative count, PLUS authoritativeGap
    final double idmGap = (((nAuthoritative - 1) * authoritativeHeight) / 2) + authoritativeGap;

    return LayoutBuilder(
      builder: (context, constraints) {
        return Stack(
          key: widget.stackKey,
          children: [
            // Main table: 3 columns, equally divided
            SingleChildScrollView(
              controller: widget.scrollController,
              child: Row(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: types.map((type) {
                  final columns = columnsByType[type]!;
                  return Expanded(
                    child: Column(
                      children: [
                        // Header
                        Container(
                          alignment: Alignment.center,
                          padding: EdgeInsets.symmetric(vertical: 8),
                          child: Text(
                            type,
                            style: TextStyle(fontWeight: FontWeight.bold, fontSize: 16),
                          ),
                        ),
                        if (type == 'Authoritative' && authoritativeGap > 0)
                          SizedBox(height: authoritativeGap),
                        if (type == 'IDM' && idmGap > 0)
                          SizedBox(height: idmGap),
                        // List of CsvBoxes for this column
                        ...List.generate(maxRows, (dataRowIdx) {
                          if (dataRowIdx < columns.length) {
                            final col = columns[dataRowIdx];
                            final keys = columnKeysByType[type]![dataRowIdx];
                            return Padding(
                              padding: const EdgeInsets.symmetric(vertical: 4, horizontal: 8),
                              child: CsvBox(
                                key: csvBoxKeysByType[type]![dataRowIdx],
                                type: type,
                                dataRowIdx: dataRowIdx,
                                col: col,
                                keys: keys,
                                cellColors: widget.cellColors,
                                csvBoxWidth: widget.csvBoxWidth,
                                onConnection: widget.onConnection,
                              ),
                            );
                          } else {
                            // Empty space to keep columns aligned
                            return SizedBox(height: boxHeight + 8); // 8 for vertical padding
                          }
                        }),
                      ],
                    ),
                  );
                }).toList(),
              ),
            ),
            // Arrow connection overlay
            Positioned.fill(
              child: IgnorePointer(
                child: CustomPaint(
                  painter: ConnectionArrowPainter(
                    connections: widget.connections,
                    columnKeysByType: columnKeysByType,
                    stackKey: widget.stackKey,
                    repaint: widget.scrollController,
                  ),
                ),
              ),
            ),
          ],
        );
      },
    );
  }
}

class ConnectionArrowPainter extends CustomPainter {
  final List<Connection> connections;
  final Map<String, List<List<GlobalKey>>> columnKeysByType;
  final GlobalKey stackKey;

  ConnectionArrowPainter({
    required this.connections,
    required this.columnKeysByType,
    required this.stackKey,
    Listenable? repaint,
  }) : super(repaint: repaint);

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = const Color(0xFF0078D4)
      ..strokeWidth = 2
      ..style = PaintingStyle.stroke;

    final stackContext = stackKey.currentContext;
    if (stackContext == null) return;
    final stackBox = stackContext.findRenderObject() as RenderBox?;
    if (stackBox == null) return;
    final stackOffset = stackBox.localToGlobal(Offset.zero);

    for (final conn in connections) {
      final fromKey = columnKeysByType[conn.fromType]?[conn.fromCol]?[conn.fromIdx];
      final toKey = columnKeysByType[conn.toType]?[conn.toCol]?[conn.toIdx];
      if (fromKey == null || toKey == null) continue;

      final fromContext = fromKey.currentContext;
      final toContext = toKey.currentContext;
      if (fromContext == null || toContext == null) continue;

      final fromBox = fromContext.findRenderObject() as RenderBox?;
      final toBox = toContext.findRenderObject() as RenderBox?;
      if (fromBox == null || toBox == null) continue;

      final fromGlobal = fromBox.localToGlobal(
        Offset(fromBox.size.width, fromBox.size.height / 2),
      );
      final toGlobal = toBox.localToGlobal(Offset(0, toBox.size.height / 2));

      final fromLocal = fromGlobal - stackOffset;
      final toLocal = toGlobal - stackOffset;

      final dx = (toLocal.dx - fromLocal.dx).abs();
      final control1 = fromLocal + Offset(dx / 2, 0);
      final control2 = toLocal - Offset(dx / 2, 0);

      final path = Path()
        ..moveTo(fromLocal.dx, fromLocal.dy)
        ..cubicTo(
          control1.dx,
          control1.dy,
          control2.dx,
          control2.dy,
          toLocal.dx,
          toLocal.dy,
        );
      canvas.drawPath(path, paint);

      const arrowSize = 10.0;
      final pathMetric = path.computeMetrics().last;
      final pos = pathMetric.getTangentForOffset(pathMetric.length);
      if (pos != null) {
        final angle = pos.angle;
        // Code Generated by Sidekick is for learning and experimentation purposes only.
        final arrowP1 = toLocal - Offset.fromDirection(angle - 0.5, arrowSize);
        final arrowP2 = toLocal - Offset.fromDirection(angle + 0.5, arrowSize);

        final arrowPath = Path()
          ..moveTo(toLocal.dx, toLocal.dy)
          ..lineTo(arrowP1.dx, arrowP1.dy)
          ..moveTo(toLocal.dx, toLocal.dy)
          ..lineTo(arrowP2.dx, arrowP2.dy);

        canvas.drawPath(arrowPath, paint);
      }
    }
  }

  @override
  bool shouldRepaint(covariant ConnectionArrowPainter oldDelegate) =>
      oldDelegate.connections != connections;
}

class Connection {
  final String fromType;
  final int fromCol, fromIdx;
  final String toType;
  final int toCol, toIdx;

  Connection(
      this.fromType,
      this.fromCol,
      this.fromIdx,
      this.toType,
      this.toCol,
      this.toIdx,
      );
}
