// Code Generated by Sidekick is for learning and experimentation purposes only.
import 'dart:collection';
import 'dart:io';
import 'dart:math';
import 'dart:typed_data';

import 'package:fluent_ui/fluent_ui.dart';
import 'package:file_picker/file_picker.dart';
import 'package:csv/csv.dart';
import 'package:screenshot/screenshot.dart';
import 'package:path_provider/path_provider.dart';

import 'csv/csv_table.dart'; // Your custom widget

class DataMapping extends StatefulWidget {
  const DataMapping({super.key});

  @override
  State<DataMapping> createState() => _DataMappingState();
}

class _DataMappingState extends State<DataMapping> {
  String? fileName;
  bool fileUploaded = false;
  String? selectedType = 'Authoritative';
  final List<String> types = ['Authoritative', 'IDM', 'Target'];
  PlatformFile? pickedFile;

  Map<String, List<Map<String, dynamic>>> columnsByType = {
    'Authoritative': [],
    'IDM': [],
    'Target': [],
  };

  List<Connection> connections = [];
  Map<String, Color> cellColors = {};
  double horizontalSpacing = 45.0;
  double csvBoxWidth = 250.0;
  final Random random = Random();

  final GlobalKey _stackKey = GlobalKey();
  final ScrollController _scrollController = ScrollController();

  // Screenshot controller for capturing the widget
  final ScreenshotController _screenshotController = ScreenshotController();

  double authoritativeHeight = 0.0;
  double idmHeight = 0.0;
  double targetHeight = 0.0;

  // Keys for each CsvBox for dynamic height measurement
  Map<String, List<GlobalKey>> csvBoxKeysByType = {
    'Authoritative': [],
    'IDM': [],
    'Target': [],
  };

  @override
  void initState() {
    super.initState();
    _scrollController.addListener(() {
      setState(() {}); // Triggers arrow repaint on scroll
    });
  }

  @override
  void dispose() {
    _scrollController.dispose();
    super.dispose();
  }

  Future<void> pickFile() async {
    FilePickerResult? result = await FilePicker.platform.pickFiles(
      type: FileType.custom,
      allowedExtensions: ['csv'],
    );
    if (result != null) {
      setState(() {
        fileName = result.files.single.name;
        fileUploaded = true;
        pickedFile = result.files.single;
      });
    }
  }

  Future<void> extractHeaderAndAddColumn() async {
    if (pickedFile != null && selectedType != null) {
      // Restrict IDM to only 1 CSV
      if (selectedType == 'IDM' && columnsByType['IDM']!.isNotEmpty) {
        showDialog(
          context: context,
          builder: (_) => ContentDialog(
            title: Text('Limit Exceeded'),
            content: Text('Only one CSV can be added to the IDM section.'),
            actions: [
              Button(
                child: Text('OK'),
                onPressed: () => Navigator.pop(context),
              ),
            ],
          ),
        );
        return;
      }

      final file = File(pickedFile!.path!);
      final content = await file.readAsString();
      final rows = const CsvToListConverter().convert(content);
      if (rows.isNotEmpty) {
        setState(() {
          final headers = rows.first.map((e) => e.toString()).toList();
          columnsByType[selectedType!]!.add({'header': headers});
          csvBoxKeysByType[selectedType!]!.add(GlobalKey());
          // Add a new key for the new CsvBox
          csvBoxKeysByType[selectedType!]!.add(GlobalKey());

          // Assign random colors for Authoritative
          if (selectedType == 'Authoritative') {
            int colIdx = columnsByType[selectedType!]!.length - 1;
            for (int i = 0; i < headers.length; i++) {
              cellColors['${selectedType!}-$colIdx-$i'] = Color.fromARGB(
                255,
                random.nextInt(256),
                random.nextInt(256),
                random.nextInt(256),
              );
            }
          }
          fileName = null;
          fileUploaded = false;
          pickedFile = null;
          selectedType = 'Authoritative';
        });

        WidgetsBinding.instance.addPostFrameCallback((_) {
          updateSectionHeights();
        });
      }
    }
  }

  void undoLastConnection() {
    if (connections.isNotEmpty) {
      setState(() {
        connections.removeLast();
        _propagateAuthoritativeColors();
      });
    }
  }

  void _propagateAuthoritativeColors() {
    for (final type in types) {
      for (int colIdx = 0; colIdx < columnsByType[type]!.length; colIdx++) {
        final col = columnsByType[type]![colIdx];
        final headers = col['header'] as List<String>;
        for (int idx = 0; idx < headers.length; idx++) {
          final cellKey = '$type-$colIdx-$idx';
          if (type == 'Authoritative') {
            continue;
          } else {
            cellColors[cellKey] = Colors.white;
          }
        }
      }
    }
    Map<String, List<String>> graph = {};
    for (final conn in connections) {
      final fromKey = '${conn.fromType}-${conn.fromCol}-${conn.fromIdx}';
      final toKey = '${conn.toType}-${conn.toCol}-${conn.toIdx}';
      graph.putIfAbsent(fromKey, () => []).add(toKey);
    }

    Set<String> visited = {};
    Queue<MapEntry<String, Color>> queue = Queue();

    for (final type in types) {
      if (type != 'Authoritative') continue;
      for (int colIdx = 0; colIdx < columnsByType[type]!.length; colIdx++) {
        final col = columnsByType[type]![colIdx];
        final headers = col['header'] as List<String>;
        for (int idx = 0; idx < headers.length; idx++) {
          final cellKey = '$type-$colIdx-$idx';
          final color = cellColors[cellKey];
          if (color != null) {
            queue.add(MapEntry(cellKey, color));
          }
        }
      }
    }

    while (queue.isNotEmpty) {
      final entry = queue.removeFirst();
      final cellKey = entry.key;
      final color = entry.value;
      if (visited.contains(cellKey)) continue;
      visited.add(cellKey);
      if (graph.containsKey(cellKey)) {
        for (final neighbor in graph[cellKey]!) {
          if (cellColors[neighbor] != color) {
            cellColors[neighbor] = color;
            queue.add(MapEntry(neighbor, color));
          }
        }
      }
    }
  }

  /// Helper to generate a fresh set of GlobalKeys for a given columnsByType map
  Map<String, List<List<GlobalKey>>> generateColumnKeysByType() {
    final Map<String, List<List<GlobalKey>>> map = {};
    for (final type in types) {
      map[type] = [
        for (var col in columnsByType[type]!)
          List.generate(
            (col['header'] as List<String>).length,
                (_) => GlobalKey(),
          ),
      ];
    }
    return map;
  }

  Future<void> exportFullTableAsImage() async {
    try {
      // Generate a *new* set of keys for the screenshot widget
      final screenshotColumnKeysByType = generateColumnKeysByType();

      // For screenshot, you may want to use the measured heights
      double totalHeight = authoritativeHeight + idmHeight + targetHeight + 100.0;

      Uint8List? image = await _screenshotController.captureFromWidget(
        MediaQuery(
          data: MediaQueryData(
            size: Size(900, totalHeight),
            devicePixelRatio: 3.0,
          ),
          child: ScaffoldPage(
            content: Container(
              color: Colors.white,
              width: 900,
              height: totalHeight,
              child: CsvTable(
                types: types,
                columnsByType: columnsByType,
                columnKeysByType: screenshotColumnKeysByType,
                cellColors: cellColors,
                connections: connections,
                stackKey: GlobalKey(),
                horizontalSpacing: horizontalSpacing,
                csvBoxWidth: csvBoxWidth,
                onConnection: (conn, fromKey, toKey) {
                  setState(() {
                    connections.add(conn);
                    _propagateAuthoritativeColors();
                  });
                },
                scrollController: ScrollController(),
                authoritativeHeight: authoritativeHeight,
                idmHeight: idmHeight,
                targetHeight: targetHeight,
                csvBoxKeysByType: csvBoxKeysByType, // Pass for measurement if needed
              ),
            ),
          ),
        ),
        pixelRatio: 3.0,
      );

      if (image != null) {
        final directory = await getApplicationDocumentsDirectory();
        final filePath = '${directory.path}/csv_mapping_export.png';
        final file = File(filePath);
        await file.writeAsBytes(image);

        showDialog(
          context: context,
          builder: (_) => ContentDialog(
            title: Text('Export Successful'),
            content: Text('Image saved to:\n$filePath'),
            actions: [
              Button(
                child: Text('OK'),
                onPressed: () => Navigator.pop(context),
              ),
            ],
          ),
        );
      }
    } catch (e) {
      showDialog(
        context: context,
        builder: (_) => ContentDialog(
          title: Text('Export Failed'),
          content: Text('Error: $e'),
          actions: [
            Button(
              child: Text('OK'),
              onPressed: () => Navigator.pop(context),
            ),
          ],
        ),
      );
    }
  }

  /// Measure all CsvBox heights and update section heights
  void updateSectionHeights() {
    setState(() {
      authoritativeHeight = getBoxHeight(csvBoxKeysByType['Authoritative']![0]);
      idmHeight = getBoxHeight(csvBoxKeysByType['IDM']![0]);
      targetHeight = getBoxHeight(csvBoxKeysByType['Target']![0]);
    });
  }

  double getBoxHeight(GlobalKey key) {
    final context = key.currentContext;
    if (context != null) {
      final box = context.findRenderObject() as RenderBox?;
      if (box != null && box.hasSize) {
        return box.size.height;
      }
    }
    return 0.0;
  }

  @override
  Widget build(BuildContext context) {
    return ScaffoldPage(
      header: PageHeader(title: Text('Data Map'),),
      content: Container(     width: double.infinity,
        height: double.infinity,
        decoration: const ShapeDecoration(
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.only(
              topLeft: Radius.circular(25.0),
              topRight: Radius.circular(25.0),
            ),
          ),
          color: Colors.white,
        ),

        child: Padding(
          padding: const EdgeInsets.all(8.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                children: [
                  SizedBox(width: 30),
                  Text("Upload CSV File : ", style: TextStyle(fontWeight: FontWeight.bold)),
                  Button(child: Text('Browse'), onPressed: pickFile),
                  if (fileUploaded) ...[
                    Padding(
                      padding: const EdgeInsets.only(left: 12.0),
                      child: Text("($fileName) "),
                    ),
                    Text('Type: ', style: TextStyle(fontWeight: FontWeight.bold)),
                    SizedBox(width: 10),
                    ComboBox<String>(
                      value: selectedType,
                      items: types
                          .map((type) => ComboBoxItem<String>(
                        value: type,
                        child: Text(type),
                      ))
                          .toList(),
                      onChanged: (value) {
                        setState(() {
                          selectedType = value;
                        });
                      },
                      placeholder: Text('Select type'),
                    ),
                    Button(
                      child: Text('ADD'),
                      onPressed: extractHeaderAndAddColumn,
                    ),
                  ],
                  Spacer(),
                  Button(
                    child: Text('Export Full Image'),
                    onPressed: exportFullTableAsImage,
                  ),
                  SizedBox(width: 20,),
                  Text("Column Spacing: ", style: TextStyle(fontWeight: FontWeight.bold)),
                  Container(
                    width: 200,
                    child: Slider(
                      min: 150,
                      max: 500,
                      value: csvBoxWidth,
                      onChanged: (value) {
                        setState(() {
                          csvBoxWidth = value;
                        });
                      },
                    ),
                  ),

                ],
              ),
              SizedBox(height: 20),
              Expanded(
                child: Screenshot(
                  controller: _screenshotController,
                  child: CsvTable(
                    types: types,
                    columnsByType: columnsByType,
                    columnKeysByType: generateColumnKeysByType(),
                    cellColors: cellColors,
                    connections: connections,
                    stackKey: _stackKey,
                    horizontalSpacing: horizontalSpacing,
                    csvBoxWidth: csvBoxWidth,
                    onConnection: (conn, fromKey, toKey) {
                      setState(() {
                        connections.add(conn);
                        _propagateAuthoritativeColors();
                      });
                    },
                    scrollController: _scrollController,
                    authoritativeHeight: authoritativeHeight,
                    idmHeight: idmHeight,
                    targetHeight: targetHeight,
                    csvBoxKeysByType: csvBoxKeysByType, // Pass for measurement if needed
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
